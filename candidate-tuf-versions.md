* TAP:
* Title: Managing TUF Versions
* Version: 1
* Last-Modified: 22-July-2019
* Author: Marina Moore, Justin Cappos
* Status: Draft
* Content-Type: text/markdown
* Created: 19-December-2018

# Abstract

This TAP clarifies how to manage updates to the TUF specification that include
non-backwards compatible (breaking) changes. A breaking change means that a
client and repository must implement the change atomically in order to continue
functioning as expected. Breaking changes to the TUF specification
include any feature that affects the parsing or
validation of metadata and any other change that means a client can no longer
safely and reliable perform an update if the repository is updated out of sync
with the client. To facilitate finding breaking changes, this TAP defines a
procedure for TUF clients to ensure that their version of the TUF specification
is compatible with the specification version of the metadata they download.

This TAP adds support for breaking changes by making changes to both
repositories and clients. Repositories will generate metadata for multiple TUF
specification versions and place the metadata in a directory structure according
to the specification version. Additionally, clients may maintain support for
previous TUF specification versions (spec versions) by having functions that parse metadata
from previous TUF versions. Clients will then determine the most recent
specification version supported by both the client and repository and use this
specification version to perform the update. In order for clients to upgrade to a
new TUF specification version, the process described in this TAP assumes that
TUF clients are able to self upgrade.

For clarity, throughout this TAP upgrading refers to the process of moving from
one TUF specification version to another while updating refers to the process
of downloading and validating packages as specified by TUF.

# Motivation

The goal of this TAP is to prevent compatibility issues while allowing breaking
changes to the TUF specification. Various TAPs, including TAPs 3 and 8 include
changes that are not backwards compatible. When breaking changes are added to a
repository in a new specification version, metadata generated by the repository will be
incompatible with clients parsing metadata formatted using an old version of
the specification. Similarly, clients using a new TUF specification version
will no longer be able to parse metadata from repositories using an old version
of the TUF specification. Because of this, clients need to check that the
version of the specification that they are using is compatible with the version
that a repository is using before validating metadata. For example, a client
uses TUF version 2.0.0 will not be able to correctly parse metadata generated
by a repository using TUF version 3.0.0 (a new version) or 1.0.0 (an old
version).

This TAP aims to support a variety of use cases when it comes to managing
updates to the TUF specification.

## Use case 1: A repository updates to a new TUF spec version

As new features become available in the TUF specification, repositories may
wish to upgrade to a new version of the specification to support these features.
This includes adding support for TAPs with breaking changes. In addition to the
ability to upgrade to a new specification version, clients should have a way to
determine what specification version the repository is using to ensure that
metadata can be safely and reliably verified. Clients who are
using an older TUF version should not use metadata from a new version that is
not backwards compatible.

## Use case 2: A client is unable to upgrade to a new TUF spec version

A client may wish to continue parsing metadata generated using an older version
of the TUF specification after a new specification version is released. This
may be due to development time needed to upgrade to the new TUF specification
version or compatibility issues with other parts of the client system (for
example a signature algorithm that is not supported). Repositories should be able to support clients
using older specification versions as well as any clients that are up to date
by maintaining metadata in both the new and old specification formats.

## Use case 3: A delegated targets role uses a different TUF spec version

A delegated role may make and sign metadata using an old version of the TUF
specification even after the repository hosting the top level roles has been
upgraded. Different roles may be managed by people in different organizations
who are not able to coordinate upgrading to a new version of the TUF
specification. To handle this, a client should be able to parse a delegation
that generates metadata with a different TUF specification version than the
repository. Therefore the client should be able to parse metadata from multiple
TUF specification versions.

## Use case 4: A client downloads metadata from multiple repositories

As described in TAP 4, TUF clients may download metadata from multiple
repositories. These repositories do not need to coordinate, and so should not
be required to upgrade to a new TUF specification version at the same time. A
client should be able to use one repository that uses TUF version 1.0.0 and
another repository that uses TUF version 2.0.0.

## Use case 5: Existing TUF clients

Existing TUF clients will still expect to download and parse metadata that uses
the current TUF specification version even once this TAP is implemented. Before
this TAP there was no method for determining compatibility between a client and
repository, so existing TUF repositories should continue to generate
backwards compatible metadata to support existing clients. This means that
non-backwards compatible TUF metadata must be stored in a different location on
the repository from existing metadata.

# Rationale

To allow for updates to the TUF specification while considering all of the
above use cases, a client must be able to parse metadata from multiple
repositories or roles that are using different versions of the TUF
specification. In addition, a repository must support clients that parse
metadata with different TUF versions. This TAP proposes a system for allowing
TUF specification version changes on both clients and repositories.

There are three possible approaches to managing versions between clients and
repositories. First, each repository could maintain multiple TUF versions while the
clients only maintain one version. In this case, TUF clients would not be able
to use metadata from multiple repositories if the repositories do not support
the same TUF version (Use Case 4). Second, each client could maintain multiple versions while
the repositories each maintain a single version. In this case, if a repository
upgrades to a new TUF version, clients will be unable to perform updates until
support for the new version is added (Use Case 2). The third option is to support multiple
versions on both clients and repositories. This option allows the clients and
repositories to be upgraded independently to support all use cases.

Repositories need to continue support for old TUF versions for some period of
time after upgrading. In this TAP, repositories support multiple versions by
separating the metadata from versions with breaking changes into different
directories. These directories allow a client to choose the most recent
metadata they support, allowing for flexibility in how long a client will
take to upgrade to a new spec version. To save space, target files should remain
in the parent directory on the
repository. The metadata files (in directories according to their spec version)
can point to target files relative to the parent directory.

Similarly, clients need to maintain multiple specification versions to allow
for communication with various repositories. To do so, this TAP recommends that
clients maintain functions that can be used to validate metadata from various
TUF specification versions. These functions allow a client to maintain old
versions of the specification while still supporting the most recent version.

As they do not affect compatibility, non-breaking changes can happen at any
time without affecting TUF's operation. To support this ability, TUF needs a
way to determine if new specification versions include any breaking changes.
This TAP clarifies how TUF version numbers are formatted
so that breaking changes are distinct from non-breaking changes. It does so
using a scheme popular across open source projects, Semantic Versioning.

# Specification

In order to allow clients and repositories to upgrade to new TUF spec versions while
maintaining support for old systems, this TAP defines a variety of procedures
to be added to the update process. This section describes how version numbers
will be defined for the TUF specification, what the repository and client must
to do support specification updates, and some special cases.

## Version Number Format

In order to make the meaning of a TUF version number change consistent and
easily understood, this TAP clarifies that the 'spec_version' field of root
metadata shall be based on [Semantic Versioning](https://semver.org/), with
version numbers in the format MAJOR.MINOR.PATCH. This is a standard format used
in other open source projects.
In accordance with Semantic Versioning, breaking changes will only occur during
a major release of the TUF spec (e.g. 1.x.x to 2.x.x). The Backwards
Compatibility section of a TAP should be used to determine whether the TAP
creates a breaking change. If the change is not backwards compatible, then
it will be part of a new major version of the TUF specification.
Non backwards compatible versions add features that change the way that TUF
processes updates, and need to be implemented on both clients and repositories
atomically to maintain security and functionality. Examples of breaking changes
are TAP 3 and TAP 8.
If the change adds a new feature that is backwards compatible, for example in
TAP 4 and TAP 10, it should be part of a new minor
version. These backwards compatible TAPs add additional features to TUF, but
clients that do not have these features will still be able to securely and
reliably perform updates from repositories that support the TAPs. There may be
minor differences in which updates a client installs across minor versions. If
a repository maintainer is worried about the impact of a minor spec change on
clients, they may choose to wait to implement the change with a major
specification version (for example, they could remain on version 2.4.6 after
  the release of 2.5).
Patches are used to fix typos and make small changes to existing features. More
details about what constitutes a major, minor, or patch change can be found at
https://semver.org/.

### Changes to TAPs
In order to manage changes to TUF, TAPs shall be tied to a version of the TUF
specification. Once a TAP is accepted a TUF Version field in the header should be updated to include
the first TUF version that will include the TAP. The Preamble Header
description in TAP 1 shall be updated to include the TUF Version field.

## How a repository updates

As described in the [Rationale](#rationale), repositories must support multiple
TUF specification versions. In order to do so, this TAP proposes a new
directory structure for repositories.

When a repository manager chooses to upgrade their repository to a new major TUF
spec version, they create a new directory on the repository named for the major
version (for example 2.0.0). This directory will contain all metadata files
with the new spec version. Target files will not be included in this directory.
After creating the directory, the repository creates and signs root, snapshot,
timestamp, and top level targets metadata using the new TUF spec version and
places these metadata files in the directory. The root file should be signed by
both the new root key and the current root key (the root key from the most
recent metadata in the previous major spec version). Clients will now be able
to use the new metadata files once their TUF spec versions are also updated.
After an update to version 2.0.0, the repository structure may look like:

```
- Target files
- 1.0.0
  |- metadata files
- 2.0.0
  |- metadata files
```

If the repository is updated to a new minor or patch spec version, this shall
be done by uploading new metadata files in the new format to the proper
directory. So if a repository updates from 2.0.0 to 2.1.0, the 2.1.0 metadata
would go in the directory named 2.0.0. Minor and patch version changes are backwards
compatible, so clients using version 2.0.0 will still be able to parse metadata
written using version 2.1.0.

A repository may continue to support old major TUF spec versions by creating
metadata both in the old location and in the new directory. The repository may
maintain as many versions as the repository manager wishes. If there are
security concerns with an old spec version, that version should be phased out
as soon as possible. The version can be phased out by no longer creating new
metadata files in that directory. In order to allow clients to parse the root
metadata chain, root metadata files shall not be deleted even once a version
is deprecated.

In order to allow a client to find the current metadata files across spec
versions, the version numbers used for consistent snapshots should be
consistent across all supported spec versions. This means that there may be a
file at 1.0.0/3.root.json as well as 2.0.0/3.root.json. Root files with the
same consistent snapshot number must additionally use the same keys so that a
client can find the next root file in whichever spec version they support.

For existing TUF clients to continue operation after this TAP is implemented,
repositories may store metadata from before TUF 1.0.0 in the top level
repository (with no directory named 0.0.0). This allows existing
clients to continue downloading metadata from the repository. So a TUF
repository that upgrades from version 0.12.0 to version 1.0.0 may look like:

```
- Targets files
- 0.12.0 metadata files
- 1.0.0
  |- 1.0.0 metadata files
```

## Changes to TUF clients

TUF clients must make a few changes to support changes to the TUF specification.

In order to find compatible updates on a repository, a client must keep track
of the TUF specification versions it supports. To do so, a global variable or
other local storage option should contain the client spec version, or spec
version range. For simplicity, this field should be formatted according to
Semantic Versioning so that it can be directly compared to the spec version in
root metadata.

TUF clients may maintain support for pervious versions of the TUF
specification. This support can be used if the client downloads metadata from a
repository or delegated role that does not support the current TUF
specification. To allow for this behavior, when a new version of the TUF client
is implemented it may contain the ability to call certain functions from the
old TUF client for parsing and validating metadata. The client may make an old
specification version obsolete if they choose by removing the functions for that specification
version, but will risk being unable to download new targets from delegations
that use the old specification version. TUF implementers should decide how many old specification
versions to support based on the expected usage of their implementation.

## Changes to the update process

When a TUF client downloads metadata from a repository, the client must
determine which spec version to use for the download. To do this, the client
looks for the highest supported version on the repository using the following procedure:

* The client determines the latest version available on the repository by
looking for the directory with the largest version number.
* If the latest version on the repository is equal to the client spec version,
the client will use this directory to download metadata.
* If the latest version on the repository is a version before the client spec version,
the client may call functions from a previous spec version client to download
the metadata. The client may support as many or as few versions as desired for
the application. If the previous version is not available, the client shall
report that an update is not possible due to an old spec version on the
repository.
* If the latest version on the repository is higher than the client spec
version, the client should report to the user that it is not using the most up
to date TUF spec version (the method of reporting is left to the discretion of
the client) then proceed with the directory that corresponds with
the latest client spec version if available. If no such directory exists, the client
terminates the update.

Once the supported directory is determined, the client shall attempt the update
using the metadata in this directory.

For example, if a client has a spec version of 3.5 and a repository has
directories for 2.0.0, 3.0.0, and 4.0.0, the client will report that spec
version 4.0 is available, then download metadata from 3.0.0. This reporting is
up to the discretion of an implementer, but it should be used to encourage
updating the client to the most recent specification version.

Alternatively, if the same client downloads metadata from a repository with
directories 1.0.0 and 2.0.0, the client could download metadata from 2.0.0
using a 2.x version of the client. If 2.x is not supported by the client, the
client will report that it is unable to perform an update.

Once the supported directory is determined, the client must validate root
metadata from this directory. If the currently trusted root file saved on the
client uses a spec version other than the supported version, the client will look
for the next root file first in the supported version, then the previous
versions until the next root file is found or the currently trusted root file's
version is reached. All root files should be verified using the major version
of the TUF client that corresponds with the major version of the root file.

So, if the currently trusted root file is named 4.root.json and uses version
1.0.0 and the highest supported version is 3.0.0, the client will look for
5.root.json first in 3.0.0, then 2.0.0, then 1.0.0. If this file is found, the
client will look for 6.root.json using the same process. To facilitate this,
the client should maintain functions to parse root files from previous spec
versions. If the client does not support the spec version of a root file, the
client shall terminate the update and report the spec version mismatch.

## Multiple Repositories

A TUF client that performs updates using multiple repositories may need to
access repositories that use different TUF specification versions. When
comparing the metadata from multiple repositories, the goal is to ensure that
the target file that is downloaded is verified by all repositories. Therefore
the client can perform validation for each repository independently, then
compare the results of the validation.

To do so, the client needs to ensure that the metadata from each
repository is valid for the given targets file.
If the repositories use different versions of the TUF specification,
the client should use the TUF version that corresponds to each repository to
validate the metadata from that repository, then compare the results. The
update is only valid if valid metadata from both repositories points to the same
target file, and this target file matches the hashes provided by each repository.
Note that different TUF versions may use different hashing algorithms. If this
is the case, both hashes should be verified independently.

## Changes to delegations

The TUF version used by a delegation does not need to match the TUF version
used by the top level metadata. The TUF client is responsible for parsing the
metadata from the top-level roles and delegations using the appropriate
specification version, similar to the process used for multiple repositories.
If there is no compatible spec version between the client
and delegation, the client should report this and terminate the update.

So that delegated targets can upgrade to new spec versions, delegated targets
metadata should be stored in directories corresponding to their major spec version just
like top level metadata on the repository. For each targets metadata file, a
TUF client should download the highest supported version. This highest
supported version will be found using the same procedure as described in
[Changes to the update process](#changes-to-the-update-process).

## Updating Trusted Root Metadata

To allow for future updates after a major version change, the client must
update their trusted root metadata to a root metadata that complies with the
new spec version. To do so, the client first downloads and verifies the current
version root metadata file. Once verified, this current version root metadata
file must be stored as the trusted root metadata. In future updates, the client
will start from the trusted root metadata when finding the next available update.

# Security Analysis

There should be minimal security impact. Ensuring that the client is up to date
should improve security in the event that a security vulnerability is patched
in a release of the spec.

A downgrade attack on the TUF specification version may be possible if an
attacker is able to block access to a directory on the repository. This would
mean that a client would use metadata from a previous specification version
when performing an update. However, the metadata would still have to be current
and properly signed. To mitigate the damage from a downgrade attack in the case
that a security flaw is found in a version of the TUF specification, the
vulnerable version of the specification should no longer be supported on the
repository (the metadata files should be revoked or allowed to expire). In
addition, clients should be upgraded to no longer support a vulnerable
specification version.

The TUF version upgrade system described in this TAP uses the root key rotation
mechanism to ensure that the client only uses valid TUF metadata. The first
time a new TUF version is used by the client, the client checks the
repository's root metadata in the new version's format. If the root metadata is
not signed by the previous trusted root key, the update does not proceed, and
the client halts the update. In this way, updates to the repository's TUF
version does not impact the security of an update.

When a client upgrades to a new TUF version, it should use TUF to ensure that
it downloads a valid new client. To do so, it should use its current TUF
version to upgrade to the new version of TUF. For example, if a client running
TUF version 2.5.0 wants to upgrade to version 3.0.0, the client should use
metadata from TUF version 2.x.x to self update. Using this technique, the TUF
client can ensure that it downloads the intended update when upgrading to a new
TUF version.

As always, authors of TUF clients should ensure that the client is a valid
implementation of TUF and that no security flaws are introduced in code. In
addition, supply chain security techniques (for example [in-toto](https://in-toto.io/in-toto.html))
should be used to ensure that vulnerabilities are not introduced into TUF
clients between when they are written and installed.

Note that an attacker on the same network could inject false metadata to block
a client from updating. However this denial of service attack is always
possible for an attacker on the network with the ability to alter network
traffic.

# Backwards Compatibility

This TAP is backwards compatible and should be implemented on all repositories
before any non-backwards compatible TAPs are released.

# Augmented Reference Implementation

TODO

# Copyright

This document has been placed in the public domain.
