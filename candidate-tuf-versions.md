* TAP:
* Title: Managing TUF Versions
* Version: 1
* Last-Modified: 22-July-2019
* Author: Marina Moore, Justin Cappos
* Status: Draft
* Content-Type: text/markdown
* Created: 19-December-2018

# Abstract

This TAP clarifies how to manage updates to the TUF specification that include non-backwards compatible (breaking) changes. A breaking change means that a client and repository must implement the change at the same time in order to continue functioning as expected. This includes any feature that affects the parsing or validation of metadata, or any other changes that mean a client can no longer safely and reliable perform an update if the repository is updated out of sync with the client. To facilitate finding breaking changes, this TAP defines a procedure for TUF clients to ensure that their version of the TUF specification is compatible with the specification version of the metadata they download. This TAP allows clients and repositories to update from their current version of the TUF specification to a version that is not backwards compatible.

# Motivation

The goal of this TAP is to prevent compatibility issues while allowing breaking changes to the TUF specification. Various TAPs, including TAPs 3 and 8 include changes that are not backwards compatible. That means that metadata generated by a repository using a new version of the specification will be incompatible with clients using the old version of the specification. Similarly, clients using the new version will no longer be able to parse metadata from repositories using the old version of the specification. Because of this, clients need to check that the version of the specification that they are using is compatible with the version that a repository is using before validating metadata.

This TAP aims to support a variety of use cases when it comes to managing updates to the TUF specification.

## Use case 1: A repository updates to a new TUF spec version

As new features become available in the TUF specification, repositories may wish to update to a new version of the specification to support these features. This includes adding support for TAPs with breaking changes. Clients should have a way to determine what specification version the repository is using to ensure that metadata can be safely and reliably verified. In addition, clients who are using an older TUF version should not use metadata from a new version that is not backwards compatible.

## Use case 2: A client is unable to update to a new TUF spec version

A client may wish to maintain an older version of the TUF specification after a new version is released. This may be due to development time needed to update to the new TUF specification version or compatibility issues. Repositories should be able to support these clients using older specification versions as well as any clients that are up to date.

## Use case 3: A delegated targets role uses a different TUF spec version

A delegated role may make and sign metadata using an old version of the TUF specification even after the top level roles have been updated. Different roles may be managed by people in different organizations who are not able to coordinate updating to a new version of the TUF specification. To handle this, a client should be able to parse a delegation that uses a different TUF specification version than the repository.

## Use case 4: A client downloads metadata from multiple repositories

As described in TAP 4, TUF clients may download metadata from multiple repositories. These repositories do not need to coordinate, and so should not be required to update to a new TUF specification version at the same time. A client should be able to use one repository that uses TUF version 1.0.0 and another repository that uses TUF version 2.0.0.

## Use case 5: Existing TUF clients

Existing TUF clients will still expect to download and parse metadata that uses the current TUF version even once this TAP is implemented on repositories. Before this TAP there was no method for determining compatibility between a client and repository, so existing clients should be supported while this change is being implemented on TUF repositories.

# Rationale

To allow for updates to the TUF specification while considering all of the above use cases, a client must be able to parse metadata from multiple repositories or roles that are using different versions of the TUF specification. However, secure and reliable verification of metadata requires that the TUF client is able to compare metadata from multiple sources. This comparison is not possible if changes to the TUF specification add or change metadata fields.

Non-breaking changes may happen independently on clients and repositories. Any specification versions that do not contain breaking changes may be updated to without worrying about compatibility. This TAP clarifies how TUF version numbers are formatted so that breaking changes are distinct from non-breaking changes.

Repositories support multiple versions by separating versions with breaking changes into different directories. These directories allow a client to choose the most recent metadata they support while allowing for flexibility in how long a client will take to update to a new spec version. Similarly, allowing the client to maintain multiple versions allows the client to use metadata from multiple directories that are not in communication and so do not coordinate an update to the most recent TUF specification.

The directory structure for breaking changes can also be used to identify the spec version used by a delegation. When parsing a delegation, a client can determine what spec versions are supported by the client and use a supported version to validate the metadata.

# Specification

In order to allow clients and repositories to update TUF spec versions while maintaining support for old systems, this TAP defines a variety of procedures to be added to the update process. This section describes how version numbers will be defined for the TUF specification, what the repository and client must to do support specification updates, and some special cases.

## Version Number Format

This TAP clarifies that the 'spec_version' field of root metadata shall be based on [Semantic Versioning](https://semver.org/), with version numbers in the format MAJOR.MINOR.PATCH. This is a standard format used in other open source projects, and makes the version numbers consistent and easily understood. In accordance with Semantic Versioning, breaking changes will only occur during a major release of the TUF spec (e.g. 1.x.x to 2.x.x). The Backwards Compatibility section of a TAP should be used to determine whether the TAP creates a breaking change. If the change is not backwards compatible, then it will be part of a new major version. Non backwards compatible versions add features that change the way that TUF processes updates, and need to be implemented on both the client and repository to maintain security and functionality. Examples of breaking changes are TAP 3 and TAP 8. If the change adds a new feature that is backwards compatible, for example in TAP 4 and TAP 10, it is not a breaking change and should be part of a new minor version. These backwards compatible TAPs add additional features to TUF, but clients that do not have these features will still be able to securely and reliably perform updates from repositories that support the TAPs. Patches are used to fix typos and make small changes to existing features. More details about what constitutes a major, minor, or patch change can be found at https://semver.org/.

### Changes to TAPs
TAPs shall be tied to a version of the TUF specification. Once a TAP is accepted the header should be updated to include the first TUF version that will include the TAP. The Preamble Header description in TAP 1 shall be updated to include this field.

## How a repository updates

When a repository manager chooses to update the repository to a new major TUF spec version, they create a new directory on the repository named for the major version (for example 2.0.0). This directory will contain all metadata files with the new spec version. After creating the directory, the repository creates and signs root, snapshot, timestamp, and top level targets metadata using the new TUF spec version and places these metadata files in the directory. Clients will now be able to use these metadata files once their TUF spec versions are also updated.

If the repository is updated to a new minor or patch spec version, this may be done by uploading new metadata files in the new format to the proper directory. So if a repository updates from 2.0.0 to 2.1.0, the 2.1.0 metadata would go in the directory named 2.0.0. Minor version changes are backwards compatible, so clients using version 2.0.0 will still be able to parse metadata written using version 2.1.0.

A repository may continue to support old major TUF spec versions by creating metadata both in the old location and in the new directory. The repository may maintain as many versions as the repository manager wishes. If there are security concerns with an old spec version, that version should be phased out as soon as possible. The version can be phased out by removing the directory containing that version from the repository.

The version numbers used for consistent snapshots should be consistent across all supported spec versions. This means that there may be a file at 1.0.0/3.root.json as well as 2.0.0/3.root.json. Root files with the same consistent snapshot number must additionally use the same keys so that a client can find the next root file in whichever spec version they support.

For existing TUF clients to continue operation while this TAP is implemented, repositories should store metadata from before TUF 1.0.0 in the top level repository (there will be no directory named 0.0.0). This allows existing clients to continue downloading metadata from the repository.

## Changes to TUF clients

TUF clients must make a few changes to support changes to the TUF specification.

The client must keep track of its version of the TUF specification. To do so, a global variable or other local storage option should contain the client spec version. For simplicity, this field should be formatted according to Semantic Versioning so that it can be directly compared to the spec version in root metadata.

In addition, TUF clients may maintain old versions of the client for compatibility reasons. These old versions can be used if the client downloads metadata from a repository or delegated role that does not support the current TUF specification. To allow for this behavior, when a new version of the TUF client is implemented it may contain the ability to call certain functions from the old TUF client for parsing and validating metadata.

## Changes to the update process

When a TUF client downloads metadata from a repository, the client must determine which spec version to use for the download. To do this, the client looks for the highest supported numbered directory on the repository.

* If the highest number on the repository is equal to the client spec version, the client will use this directory to download metadata.
* If the highest number on the repository is less than the client spec version, the client may call functions from a previous spec version client to download the metadata. The client may support as many or as few versions as desired for the application. If a previous version is not available, the client shall report that an update is not possible due to an old spec version on the repository.
* If the highest number on the repository is higher than the client spec version, the client should report to the user that it is not using the most up to date TUF spec version then proceed with the directory that corresponds with the client spec version if available. If no such directory exists, the client terminates the update.

Once the supported directory is determined, the client shall attempt the update using the metadata in this directory.

For example, if a client has a spec version of 3.5 and a repository has directories for 2.0.0, 3.0.0, and 4.0.0, the client will report that spec version 4.0 is available, then download metadata from 3.0.0.

Alternatively, if the same client downloads metadata from a repository with directories 1.0.0 and 2.0.0, the client could download metadata from 2.0.0 using a 2.x version of the client. If a 2.x version is not available, the client will report that it is unable to perform an update.

Once the supported directory is determined, the client must validate root metadata from this directory. If the currently trusted root file uses a version other than the supported version, the client will look for the next root file first in the supported version, then the previous versions until the next root file is found or the currently trusted root file's version is reached. All root files should be verified using the major version of the TUF client that corresponds with the major version of the root file.

So, if the currently trusted root file is named 4.root.json and uses version 1.0.0 and the highest supported version is 3.0.0, the client will look for 5.root.json first in 3.0.0, then 2.0.0, then 1.0.0. If this file is found, the client will look for 6.root.json using the same process. To facilitate this, the client should maintain functions to parse root files from previous spec versions. If the client does not support the spec version of a root file, the client shall terminate the update and report the spec version mismatch.

## Changes to map file procedure

When a TUF client contains a map file for multiple repositories, an additional step must be added to ensure a consensus is possible across repositories that are using different spec versions. In order for this procedure to work, all repositories should maintain metadata according to old spec versions as explained in [How a repository updates](#how-a-repository-updates).

When parsing a mapping, the client should first look for a threshold as described in [TAP 4](https://github.com/theupdateframework/taps/blob/master/tap4.md) using the client's TUF spec version. If a threshold is not met with this spec version, the client should try with the previous major spec version, and so on until a threshold is reached or the version becomes negative.  

## Changes to delegations

Delegated targets should be stored in directories with their major spec version just like top level metadata on the repository. For each targets metadata file, a TUF client should download the highest supported version. This highest supported version will be found using the same procedure as described in [Changes to the update process](#changes-to-the-update-process).

In order to support this behavior, TUF clients should maintain the ability to parse targets metadata files from old spec versions. This can be done through functions that call sections of the old client version and translate these to be used by the new client. The client may make an old version obsolete if they choose, but will risk being unable to download new targets from delegations that are not updated.

## Updating Trusted Root Metadata

After a major version change, the client must update their trusted root metadata to the root metadata that complies with the new spec version. To do so, the client first downloads and verifies the current version root metadata file. Once verified, this current version root metadata file must be stored as the trusted root metadata. In future updates, the client will start from the trusted root metadata when finding the next available update.

# Security Analysis

There should be minimal security impact. Ensuring that the client is up to date should improve security in the event that a security vulnerability is patched in a release of the spec.

# Backwards Compatibility

This TAP is backwards compatible and should be implemented on all clients before any other non-backwards compatible TAPs are released.

# Augmented Reference Implementation

TODO

# Copyright

This document has been placed in the public domain.
